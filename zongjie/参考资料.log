Spring
http://www.cnblogs.com/ITtangtang/p/3978349.html
http://www.cnblogs.com/question-sky/tag/Spring/
优秀参考资料
http://blog.csdn.net/chjttony/article/category/1239946/2

Spring IOC
解释 Spring IOC 最好的文章
http://www.cnblogs.com/zrtqsk/p/4028453.html
Spring 循环依赖
http://jinnianshilongnian.iteye.com/blog/1415278

SpringMVC
http://www.cnblogs.com/question-sky/tag/SpringMVC/

Document 读取 XML, 用 DTD 校验 XML
http://blog.csdn.net/disiwei1012/article/details/75209030
http://www.cnblogs.com/nerxious/archive/2013/05/03/3057191.html
http://acooly.iteye.com/blog/1707354
(下面这个非常好)
http://uuu999ggg.iteye.com/blog/1003626

Spring 解析自定义 XSD 的步骤
1. 查看 schema 中 "xsi:schemaLocation" 前面的域名, 后面是具体文件名.
2. 通过 PluggableSchemaResolver 会根据 "META-INF/spring-schemas" 里面的值. 通过前面的文件名对应 properties 的值找到具体本地的 xsd 文件, 然后进行 resolve

通过三个类
PluggableSchemaResolver 继承 EntityResolver 通过一个 properties 文件把 url 映射为本地文件
DelegatingEntityResolver 继承 EntityResolver
ResourceEntityResolver 继承 DelegatingEntityResolver


Spring 源码 之坎
1. beanFactory 为什么有这么多的接口及实现类, 好混乱, 又好复杂

Proxy
1. JDK 原理
生成一个 Proxy$01 类, 实现需要代理的类的接口, 并且内部通过 InvokeHandler.invoke 方法通过 Method.invoke(Object, args) 来进行调用

Interface A {
    doAction{}
}

Class B implementation A {
    doAction {
        System.out.println("test");
    }
}

InvokeHandlerImpl implementation InvokeHandler{
    private A a;
    public Object invoke(Method, method, Object[] args){
        method.invoke(a, args);
    }
}

Proxy$B extend Proxy implementation A {

    Proxy$B(InvokeHandler invokeHandler){
        super(invokeHandler);
    }

    public final void doAction (){
        try{
            this.invokeHandler.invoke(this, m1, null);
        }catch(Exxception e){

        }
    }

    static {
        m1 = Class.forName("B").getMethod("doAction", new Class[0])
    }
}

1. 为什么 精通 Spring-framework 的人这么少
原因:
    1. 代码量太大, 没个 2/3 个月的时间投入, 不可能吃透
    2. 很多资料 覆盖的知识点不全, 而且新版本的数据没有阐述 Spring 1.x, 2.x, 4.x 里面的知识点